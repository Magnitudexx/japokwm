.\" Generated by scdoc 1.11.1
.\" Complete documentation for this program is not available as a GNU info page
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.nh
.ad l
.\" Begin generated content:
.TH "japokwm" "5" "2021-06-08"
.P
.SH NAME
.P
japokwm - tiling made easy
.P
.SH DESCRIPTION
A japokwm configuration file is a lua file that is executed by japokwm.\& You can
use built-in functions with it to change the behavior of your window manager and
change various settings.\& An example config is likely present in
/etc/japokwm/init.\&lua for you to check out.\&
.P
.SH Terminology
\fBcontainer\fR 
.br
	an array consisting of 4 floats where they represent the relative x, y, 
.br
	width and height respectively 
.br
\fBrelative x/y/width/height\fR 
.br
	when x = 0 you are at the left side of the screen.\& At x = 1 you are on 
.br
	the right side.\& At x = 0.\&5 you are at half the screen 
.br
	when width = 0 it is literally 0.\& When it is 1 it is as wide as the 
.br
	current monitor.\& When width = 0.\&5 it means half the width of the monitor 
.br
\fBroot\fR
.RS 4
everything you see when you don't have a window open
.RE
\fBwindow\fR 
.br
	the container and the content you see in it
.P
.SH Types
Here are types listed which are used in Japokwm's config file.\& Those Types are
important because you won't understand the function definitions otherwise.\&
.TS
allbox;l lx lx
l lx lx
l lx lx
l lx lx
l lx lx
l lx lx
l lx lx
l lx lx.
T{
\fBTypes\fR
T}	T{
\fBDescription\fR
T}	T{
\fBExample\fR
T}
T{
nil
T}	T{
basic lua nil
T}	T{
nil
T}
T{
string
T}	T{
basic lua string
T}	T{
"string"
T}
T{
number
T}	T{
basic lua number
T}	T{
3.\&5
T}
T{
integer
T}	T{
basic lua number that must be a whole number
T}	T{
3
T}
T{
function
T}	T{
basic lua number that must be a whole number
T}	T{
function() print("execute") end
T}
T{
boolean
T}	T{
basic lua boolean
T}	T{
true | false
T}
T{
direction
T}	T{
an exist
T}	T{
true | false
T}
.TE
.sp 1
In Japokwm multiple types of tables are used to different kinds of information.\&
We gave those special tables certain names so that you can tell them apart more
easily.\& To show the content of a table we write one as follows:
.P
.nf
.RS 4
table(string: string, string: integer, \&.\&.\&.)
.fi
.RE
.P
This table consists out of elements consisting out of keys of type string and a
value of type string and elements consisting out of keys of type string and
values of type integers which can exist anywhere between 0 and infinity times
denoted by ".\&.\&.\&"
.P
Tables without keys are called arrays and are denoted as follows:
.P
.nf
.RS 4
array(string, integer, \&.\&.\&.)
.fi
.RE
.P
This is an array with a string, then an integer followed by any number of
integers
.P
.TS
allbox;l lx lx
l lx lx
l lx lx
l lx lx
l lx lx
l lx lx
l lx lx
l lx lx
l lx lx.
T{
\fBTypes\fR
T}	T{
\fBDescription\fR
T}	T{
\fBExample\fR
T}
T{
container
T}	T{
array(number, number, number, number) where each number represents x, y, width or height in the given order
T}	T{
{0.\&3, 0.\&1, 0.\&5, 0.\&7}
T}
T{
layout_data_element
T}	T{
array(container, .\&.\&.\&)
T}	T{
{{0.\&3, 0.\&1, 0.\&5, 0.\&7}, {0.\&3, 0.\&1, 0.\&5, 0.\&7},}
T}
T{
layout_data
T}	T{
array(layout_data_element, .\&.\&.\&) where the first layout_data_element will be used
T}	T{
{ { {0.\&3, 0.\&1, 0.\&5, 0.\&7}, {0.\&3, 0.\&1, 0.\&5, 0.\&7}, }, { {0.\&3, 0.\&1, 0.\&5, 0.\&7}, {0.\&3, 0.\&1, 0.\&5, 0.\&7},} }
T}
T{
layout_info
T}	T{
array(string) The 1st argument represents the directory/name of the layout
T}	T{
{"main"} -- the directory/name is "main"
T}
T{
color
T}	T{
array(number, number, number, number) the arguments represents rgba respectively between 0.\&.\&1
T}	T{
{0, 1, 1, 1} -- cyan
T}
T{
keybinding
T}	T{
array(string, function()) the arguments are the keys given by the string ++ and the function representing the action that will be taken
T}	T{
{"M-S-e", function() print("test") end}
T}
T{
rule
T}	T{
array(string, string, function(n)) the arguments are class name and rule ++ respectively.\& The class and name are obtained from the window and the rule ++ is just a function that gets the container id.\& The function will be ++ executed when the layout is rearrange.\&
T}	T{
{"anki", "", function() print("test") end}
T}
T{
monrule
T}	T{
array(string, function()) the arguments are name and rule respectively.\& The class and name are obtained from the window and the rule is just a function without arguments.\& The function will be executed when a layout is created.\&
T}	T{
{"", function() print("test") end}
T}
.TE
.sp 1
.P
.SH NAMESPACES
.TS
allbox;l lx
l lx
l lx
l lx
l lx
l lx
l lx.
T{
\fBNamespace\fR
T}	T{
\fBDescription\fR
T}
T{
\fBaction\fR
T}	T{
Execute an action
T}
T{
config
T}	T{
Configure certain properties or the behavior of the window manager
T}
T{
container
T}	T{
Configure certain properties or the behavior of a container
T}
T{
event
T}	T{
Bind a function to an event
T}
T{
layout
T}	T{
Configure certain properties or the behavior of a layout
T}
T{
l
T}	T{
Configure things locally to the layout
T}
.TE
.sp 1
.SH ACTION
\fBarrange()\fR 
.br
	Arrange containers to the given information
.P
\fBdecrease_nmaster()\fR 
.br
	decrease the number of master windows
.P
\fBexec(cmd)\fR 
.br
	execute a shell command in a new pid 
.br
<where> 
.br
	cmd: string - the command
.P
\fBfocus_container(i)\fR 
.br
	focus the container at i 
.br
<where> 
.br
	i: integer - position on the stack
.P
\fBfocus_on_hidden_stack(i)\fR 
.br
	replace current container with a hidden container 
.br
<where> 
.br
	i: integer - relative position on the hidden stack
.P
\fBfocus_on_stack(i)\fR 
.br
	focuses the container at relative i 
.br
<where> 
.br
	i: integer - relative position on the stack
.P
\fBincrease_nmaster()\fR 
.br
	increase the number of master windows
.P
\fBkill(i)\fR 
.br
	kill the window at position i
<where> 
.br
	i: integer - position on the stack
.P
\fBload_layout(l)\fR 
.br
	load a layout 
.br
<where> 
.br
	l: table(a: string, b: string) where
.P
\fBload_layout_in_set(set, i: position)\fR 
.br
	load a layout in the layout set 
.br
<where> 
.br
	set: string - the name of the set 
.br
	i: the layout
.P
\fBload_next_layout_in_set(set)\fR 
.br
	load the next layout in the layout set 
.br
<where> 
.br
	set: the name of the set
.P
\fBload_prev_layout_in_set(set)\fR 
.br
	load the previous layout in the layout set 
.br
<where> 
.br
	set: string - the name of the set
.P
\fBmove_container_to_workspace(i)\fR 
.br
	move the selected container to the workspace i 
.br
<where> 
.br
	i: integer
.P
\fBmove_resize(e)\fR 
.br
	move and resize the selected container to the mouse 
.br
<where> 
.br
	e: enum - given by info.\&cursor.\&mode
.P
\fBmove_to_scratchpad(i)\fR 
.br
	move the window at position i to the scratchpad
<where> 
.br
	i: integer - position on the stack
.P
\fBquit()\fR 
.br
	quit the window manager
.P
\fBrepush(i, j)\fR 
.br
	push the container into the master area 
.br
<where> 
.br
	i: integer - container that needs to repushed 
.br
	j: integer - new position it will be pushed to
.P
\fBresize_main(n)\fR 
.br
	resize the master area 
.br
<where> 
.br
	n: number - relative size (between 0 and 1)
.P
\fBset_floating(b)\fR 
.br
	set the selected container's floating status 
.br
<where> 
.br
	b: boolean - status(true/false)
.P
\fBset_nmaster(i)\fR
.RS 4
set the amount of master windows 
.br
<where> 
.br
	i: integer - the number of master windows
.P
.RE
\fBshow_scratchpad()\fR
.RS 4
show the first window on the scratchpad.\& If it is already visible hide it
instead and move it to the end of the scratchpad.\&
.P
.RE
\fBswap_workspace(i, i2)\fR
.RS 4
swap the workspace i with the workspace i2 
.br
<where> 
.br
	i: integer workspace at i 
.br
	i2: integer workspace at i2
.P
.RE
\fBtoggle_bars()\fR 
.br
	toggles layer_shell bars
.P
\fBtoggle_floating()\fR 
.br
	toggles if current container is floating
.P
\fBtoggle_layout()\fR 
.br
	toggle previous layout
.P
\fBtoggle_workspace()\fR 
.br
	toggle previous workspace
.P
\fBview(i)\fR 
.br
	view the ith workspace 
.br
<where> 
.br
	i: integer - ith workspace
.P
\fBzoom()\fR 
.br
	like dwm's zoom
.P
.SH CONTAINER
\fBcontainer_set_alpha(i, alpha)\fR 
.br
	set the opacity of the container 
.br
<where> 
.br
	i: integer - position of the container
.RS 4
alpha: float - new alpha value of the container
.P
.RE
\fBcontainer_set_ratio(i, ratio)\fR 
.br
	set the ratio of the container 
.br
<where> 
.br
	i: integer - position of the container
.RS 4
ratio: float - ratio of the container (if 0 it is interpreted as no ratio)
.P
.RE
\fBcontainer_set_sticky(i, sticky)\fR 
.br
	make container sticky 
.br
<where> 
.br
	i: integer - position of the container
.RS 4
sticky: boolean - whether container is sticky
.P
.RE
.SH EVENT
\fBset_update_function(func)\fR 
.br
	set the update function 
.br
<where> 
.br
	func: function(n) - it will be called every time the another 
.br
		layout_element will be loaded 
.br
	<where> 
.br
		n: integer - n represents the amount of containers  
.P
\fBset_on_focus_function(func)\fR 
.br
	set the update function 
.br
<where> 
.br
	func: function(n) - it will be called every time a new container is 
.br
	selected layout_element will be loaded 
.br
	<where> 
.br
		n: integer - n represents the current container position
.P
\fBset_on_start_function(func)\fR 
.br
	set the function that is executed on start of the windowmanager.\&
<where> 
.br
	func: function() - it will be called when the windowmanager launches
.P
\fBset_create_container_function()\fR 
.br
	set the create_container function
<where> 
.br
	func: function(n) - it will be called every time a container is created 
.br
		by Japokwm 
.br
	<where> 
.br
		n: integer - n represents the current container position
.P
.SH LAYOUT
\fBset(name, layout_data)\fR 
.br
	set layout 
.br
<where> 
.br
	name: (string) - name of this layout
.RS 4
layout_data: layout_data - layout_data for the layout
.P
.RE
.SH INFO
\fBget_this_container_count()\fR 
.br
	get the amount of visible containers in this workspace
<return> 
.br
	integer - number of containers
.P
\fBthis_container_position()\fR 
.br
	get the position the container is at 
.br
<return> 
.br
	integer - position of the focused container
.P
\fBget_nmaster()\fR 
.br
	get the number of master windows 
.br
<return> 
.br
	 integer - number of master windows
.P
\fBget_next_empty_workspace()\fR 
.br
	Get next workspaces not used by any window
<return> 
.br
	integer - workspace id of this empty workspace
.P
\fBget_workspace()\fR 
.br
	Get the workspaces id of the current workspace
<return> 
.br
	integer - workspace id
.P
\fBget_container_under_cursor()\fR 
.br
	get the container beneath the cursor 
.br
<return> 
.br
	integer - container id
.P
\fBis_container_not_in_limit()\fR 
.br
	returns whether a container doesn't violate min/max_width/height of the
.RS 4
constraints 
.br
<return> 
.br
	boolean - whether it is in limit
.P
.RE
\fBis_container_not_in_master_limit()\fR 
.br
	returns whether a container doesn't violate min/max_width/height of the 
.br
	master constraints 
.br
<return> 
.br
	boolean - whether it is in limit
.P
.SH CONFIG
.P
\fBcreate_layout_set(name, layouts)\fR
.RS 4
create a new layout_set 
.br
<where> 
.br
	name: string - name of the layout set 
.br
	layouts: layout_info - layouts that belong to this set
.P
.RE
\fBcreate_workspaces(names)\fR
.RS 4
create or recreate all workspaces with an array of names for each 
.br
	workspace.\& The order of the workspace can be set by prefixing the names 
.br
	with: "%i:" where %i represents the position the workspace will be on.\& 
.br
<where> 
.br
	names: array(string)
.P
.RE
\fBreload()\fR 
.br
	reload the config file
.P
\fBset_arrange_by_focus(b)\fR 
.br
	if b is true windows will be tiled by means of the focus stack
<where> 
.br
	b: boolean
.P
\fBset_border_color(color)\fR 
.br
	set the border color of windows 
.br
<where> 
.br
	color: color
.P
\fBset_default_layout(l)\fR 
.br
	set the default layout 
.br
<where> 
.br
	l: string - name/directory of the layout
.P
\fBset_float_borderpx(f)\fR 
.br
	set the border width of floating windows in pixel 
.br
<where> 
.br
	f: border width in pixel
.P
\fBset_focus_color(color)\fR 
.br
	set the color of the focused window 
.br
<where> 
.br
	color: color
.P
\fBset_focus_color(color)\fR 
.br
	set the color of the focused window 
.br
<where> 
.br
	color: color
.P
\fBset_hidden_edges(d)\fR 
.br
	set the directions edge borders will be hidden 
.br
<where> 
.br
	d: direction
.P
\fBset_keybinds(k)\fR
.RS 4
set all keybindings existing in Japokwm and overwrite old keybindings 
.br
<where> 
.br
	k: array(keybinding, .\&.\&.\&)
.P
.RE
\fBset_layout_constraints(min_width: a, max_width: b, min_height: c, max_height: d)\fR 
.br
	Set the minimum and maximum dimensions of resizing any window 
.br
<where> 
.br
	a, b, c, d: number - relative width/height
.P
\fBset_master_constraints(min_width: a, max_width: b, min_height: c, max_height: d)\fR 
.br
	Set the minimum and maximum dimensions of resizing the master area 
.br
<where> 
.br
	a, b, c, d: number - relative width/height
.P
\fBset_master_layout_data(data)\fR 
.br
	set the way the windows in the master area are tiled depending on nmaster 
.br
<where> 
.br
	data: layout_data
.P
\fBset_mod(i)\fR 
.br
	set the modifier which is any number between 1 and 4.\& This causes the 
.br
	"mod" string to be replaced such that they correspond to the correct 
.br
	modifiers:
.P
.TS
allbox;l lx lx
lx lx lx
lx lx lx
lx lx lx
lx lx lx.
T{
Number
T}	T{
Mod
T}	T{
Literally
T}
T{
1
T}	T{
Alt
T}	T{
"Alt_L"
T}
T{
2
T}	T{
Number lock
T}	T{
"Num_Lock"
T}
T{
3
T}	T{
AltGr
T}	T{
"ISO_Level3_Shift"
T}
T{
4
T}	T{
Super
T}	T{
"Super_L"
T}
.TE
.sp 1
<where> 
.br
	i: integer
.P
\fBset_monrules(r)\fR 
.br
	set the rules applied for the respective monitor 
.br
<where> 
.br
	r: array(monrule)
.P
\fBset_outer_gaps(i)\fR 
.br
	set how large the gap between all the windows and the root is 
.br
<where> 
.br
	i: integer - the size of those gaps in pixel
.P
\fBset_repeat_delay(i)\fR 
.br
	how long do you need to wait before the keyboard starts to repeat in 
.br
<where> 
.br
	i: integer - i is the delay given in milliseconds
.P
\fBset_repeat_rate(i)\fR 
.br
	how often will a character repeat 
.br
<where> 
.br
	i: integer - i is the repeat rate given in milliseconds
.P
\fBset_resize_data(data)\fR
.RS 4
set the resize direction of the layout 
.br
	; TODO improve this
.RE
<where> 
.br
	data: array(array(integer, .\&.\&.\&))
.P
\fBset_resize_direction(d)\fR 
.br
	set the resize direction of the layout 
.br
<where> 
.br
	d: direction
.P
\fBset_root_color(color)\fR 
.br
	set color of the root 
.br
<where> 
.br
	color: color
.P
\fBset_rules(r)\fR 
.br
	set the rules 
.br
<where> 
.br
	r: array(rule)
.P
\fBset_sloppy_focus(b)\fR 
.br
	set whether to use sloppy focus or not.\& If sloppy focus is activated you 
.br
	will focus windows by hovering above them.\& 
.br
<where> 
.br
	b: boolean
.P
\fBset_smart_hidden_edges(b)\fR 
.br
	if true edges are only hidden (see set_hidden_edges) if the number of 
.br
	containers in the current workspace <= 1 
.br
<where> 
.br
	b: boolean
.P
\fBset_tile_borderpx(i)\fR 
.br
	set the border width of tiled windows in pixel 
.br
<where> 
.br
	i: integer - border width in pixel
.P
.SH MONITOR
\fBset_scale(n)\fR 
.br
	scale the monitor by n
<where> 
.br
	n: number - the percentage the monitor will be scaled e.\&g.\& 1 = 100%
.P
\fBset_transform(e)\fR 
.br
	scale the monitor by n
<where> 
.br
	% TODO: what is this enum?\&
.RS 4
e: WL_LIST_TRANSFORMATION - an enum provided by info.\&monitor.\&transform
.P
.RE
.SH LOCAL
config beginning with l are considered local config and only apply for the
current layout.\& There are basically the same functions as usual but only some of
them can be used locally.\& Here is a list of available functions:
.P
.SS CONFIG
set_arrange_by_focus 
.br
set_border_color 
.br
set_float_borderpx 
.br
set_focus_color 
.br
set_hidden_edges 
.br
set_inner_gaps 
.br
set_layout_constraints 
.br
set_master_constraints 
.br
set_master_layout_data 
.br
set_outer_gaps 
.br
set_resize_data 
.br
set_resize_direction 
.br
set_sloppy_focus 
.br
set_smart_hidden_edges 
.br
set_tile_borderpx
.P
.SS EVENT
set_create_container_function 
.br
set_update_function 
.br
 
.P
.SH SEE ALSO
\fBjapokwm\fR(1)
