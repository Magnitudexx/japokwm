root.c:32:14:    root.w = m->m;
tile/tileUtils.c:28:9:        m->m = *wlr_output_layout_get_box(output_layout, m->wlr_output);
tile/tileUtils.c:28:58:        m->m = *wlr_output_layout_get_box(output_layout, m->wlr_output);
tile/tileUtils.c:33:29:        if (selected_layout(m->tagset).funcId) {
tile/tileUtils.c:37:60:            if (strcmp(prev_layout.symbol, selected_layout(m->tagset).symbol)
tile/tileUtils.c:39:47:                prev_layout = selected_layout(m->tagset);
tile/tileUtils.c:40:67:                lua_rawgeti(L, LUA_REGISTRYINDEX, selected_layout(m->tagset).funcId);
tile/tileUtils.c:56:36:            wl_list_for_each(con, &m->stack, slink) {
tile/tileUtils.c:57:45:                if (!visibleon(con->client, m->tagset))
tile/tileUtils.c:135:32:        wl_list_for_each(con, &m->containers, slink) {
tile/tileUtils.c:137:37:            if (i < wl_list_length(&m->stack)) {
tile/tileUtils.c:152:28:    wl_list_for_each(con, &m->containers, clink)
popup.c:52:32:        wl_list_for_each(con, &m->stack, slink) {
render/render.c:82:36:    wl_list_for_each_reverse(con, &m->stack, slink) {
render/render.c:84:37:        if (!visibleon(con->client, m->tagset))
render/render.c:92:56:        wlr_output_layout_output_coords(output_layout, m->wlr_output, &ox, &oy);
render/render.c:107:35:            scalebox(&borders[i], m->wlr_output->scale);
render/render.c:109:21:                    m->wlr_output->transform_matrix);
render/render.c:118:24:        rdata.output = m->wlr_output;
render/render.c:133:36:    wl_list_for_each_reverse(con, &m->layer_stack, llink) {
render/render.c:140:37:        if (!visibleon(con->client, m->tagset) || !wlr_output_layout_intersects(
render/render.c:141:36:                    output_layout, m->wlr_output, &con->geom))
render/render.c:149:24:        rdata.output = m->wlr_output;
render/render.c:202:24:        rdata.output = m->wlr_output;
render/render.c:222:35:    if (!wlr_output_attach_render(m->wlr_output, NULL))
render/render.c:227:33:        wlr_renderer_begin(drw, m->wlr_output->width, m->wlr_output->height);
render/render.c:227:55:        wlr_renderer_begin(drw, m->wlr_output->width, m->wlr_output->height);
render/render.c:233:29:        render_independents(m->wlr_output);
render/render.c:246:44:        wlr_output_render_software_cursors(m->wlr_output, NULL);
render/render.c:253:23:    wlr_output_commit(m->wlr_output);
container.c:17:21:    wl_list_insert(&m->containers, &con->clink);
container.c:18:21:    wl_list_insert(&m->focus_stack, &con->flink);
container.c:49:25:    if (wl_list_length(&m->focus_stack) >= 2)
container.c:52:29:            wl_container_of(m->focus_stack.next->next, con, flink);
container.c:66:34:    if (abs(i) > wl_list_length(&m->focus_stack))
container.c:72:32:        struct wl_list *pos = &m->focus_stack;
container.c:80:32:        struct wl_list *pos = &m->focus_stack;
container.c:95:32:        wl_list_for_each(con, &m->stack, slink) {
container.c:110:32:        wl_list_for_each(con, &m->stack, slink) {
container.c:126:28:    wl_list_for_each(con, &m->stack, slink) {
container.c:140:29:            wl_list_insert(&m->stack, &con->slink);
container.c:144:34:            wl_list_for_each(c, &m->stack, slink) {
container.c:149:33:            if (!wl_list_empty(&m->stack)) {
container.c:152:33:                wl_list_insert(&m->stack, &con->slink);
container.c:162:25:        wl_list_insert(&m->containers, &con->link);
container.c:164:25:        wl_list_insert(&m->focus_stack, &con->flink);
container.c:259:21:    wl_list_insert(&m->focus_stack, &con->flink);
container.c:280:32:        wl_list_for_each(con, &m->focus_stack, flink)
stack:1:27:root.c:32:14:    root.w = m->m;
stack:2:31:tile/tileUtils.c:28:9:        m->m = *wlr_output_layout_get_box(output_layout, m->wlr_output);
stack:2:80:tile/tileUtils.c:28:9:        m->m = *wlr_output_layout_get_box(output_layout, m->wlr_output);
stack:3:32:tile/tileUtils.c:28:58:        m->m = *wlr_output_layout_get_box(output_layout, m->wlr_output);
stack:3:81:tile/tileUtils.c:28:58:        m->m = *wlr_output_layout_get_box(output_layout, m->wlr_output);
stack:4:52:tile/tileUtils.c:33:29:        if (selected_layout(m->tagset).funcId) {
stack:5:83:tile/tileUtils.c:37:60:            if (strcmp(prev_layout.symbol, selected_layout(m->tagset).symbol)
stack:6:70:tile/tileUtils.c:39:47:                prev_layout = selected_layout(m->tagset);
stack:7:90:tile/tileUtils.c:40:67:                lua_rawgeti(L, LUA_REGISTRYINDEX, selected_layout(m->tagset).funcId);
stack:8:59:tile/tileUtils.c:56:36:            wl_list_for_each(con, &m->stack, slink) {
stack:9:68:tile/tileUtils.c:57:45:                if (!visibleon(con->client, m->tagset))
stack:10:56:tile/tileUtils.c:135:32:        wl_list_for_each(con, &m->containers, slink) {
stack:11:61:tile/tileUtils.c:137:37:            if (i < wl_list_length(&m->stack)) {
stack:12:52:tile/tileUtils.c:152:28:    wl_list_for_each(con, &m->containers, clink)
stack:13:46:popup.c:52:32:        wl_list_for_each(con, &m->stack, slink) {
stack:14:58:render/render.c:82:36:    wl_list_for_each_reverse(con, &m->stack, slink) {
stack:15:59:render/render.c:84:37:        if (!visibleon(con->client, m->tagset))
stack:16:78:render/render.c:92:56:        wlr_output_layout_output_coords(output_layout, m->wlr_output, &ox, &oy);
stack:17:58:render/render.c:107:35:            scalebox(&borders[i], m->wlr_output->scale);
stack:18:44:render/render.c:109:21:                    m->wlr_output->transform_matrix);
stack:19:47:render/render.c:118:24:        rdata.output = m->wlr_output;
stack:20:59:render/render.c:133:36:    wl_list_for_each_reverse(con, &m->layer_stack, llink) {
stack:21:60:render/render.c:140:37:        if (!visibleon(con->client, m->tagset) || !wlr_output_layout_intersects(
stack:22:59:render/render.c:141:36:                    output_layout, m->wlr_output, &con->geom))
stack:23:47:render/render.c:149:24:        rdata.output = m->wlr_output;
stack:24:47:render/render.c:202:24:        rdata.output = m->wlr_output;
stack:25:58:render/render.c:222:35:    if (!wlr_output_attach_render(m->wlr_output, NULL))
stack:26:56:render/render.c:227:33:        wlr_renderer_begin(drw, m->wlr_output->width, m->wlr_output->height);
stack:26:78:render/render.c:227:33:        wlr_renderer_begin(drw, m->wlr_output->width, m->wlr_output->height);
stack:27:56:render/render.c:227:55:        wlr_renderer_begin(drw, m->wlr_output->width, m->wlr_output->height);
stack:27:78:render/render.c:227:55:        wlr_renderer_begin(drw, m->wlr_output->width, m->wlr_output->height);
stack:28:52:render/render.c:233:29:        render_independents(m->wlr_output);
stack:29:67:render/render.c:246:44:        wlr_output_render_software_cursors(m->wlr_output, NULL);
stack:30:46:render/render.c:253:23:    wlr_output_commit(m->wlr_output);
lib/actions/actions.c:108:40:        wl_list_for_each_reverse(con, &m->stack, slink) {
lib/actions/actions.c:114:25:    if (!wl_list_empty(&m->stack)) {
monitor.c:43:19:    wl_list_init(&m->containers);
monitor.c:44:19:    wl_list_init(&m->stack);
monitor.c:45:19:    wl_list_init(&m->focus_stack);
monitor.c:46:19:    wl_list_init(&m->layer_stack);
monitor.c:53:5:    m->wlr_output = output;
monitor.c:54:5:    m->tagset = create_tagset(&tagNames, 0, 0);
monitor.c:55:25:    push_seleceted_tags(m->tagset, TAG_ONE);
monitor.c:58:13:            m->mfact = r->mfact;
monitor.c:59:13:            m->nmaster = r->nmaster;
monitor.c:62:33:            set_selected_layout(m->tagset, *r->lt);
monitor.c:68:5:    m->frame.notify = render_frame;
monitor.c:69:43:    wl_signal_add(&output->events.frame, &m->frame);
monitor.c:70:5:    m->destroy.notify = destroy_monitor;
monitor.c:71:45:    wl_signal_add(&output->events.destroy, &m->destroy);
monitor.c:73:28:    wl_list_insert(&mons, &m->link);
monitor.c:116:21:    wl_list_remove(&m->destroy.link);
client.c:43:40:        return c->tagset->selTags[0] & m->tagset->selTags[0];
